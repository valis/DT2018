-- 1. \data Pair, проекции.

-- Мы можем определить тип пар натуральных чисел через \data.
\data NatPair | natPair Nat Nat

-- Проекции можно определить через паттерн матчинг.
\func natFst (p : NatPair) : Nat
  | natPair x _ => x

\func natSnd (p : NatPair) : Nat
  | natPair _ y => y

-- 2. Эта-эквивалентность для \Pi-типов, \Sigma-типов, \record.

\func idp {A : \Type} {a : A} => path (\lam _ => a)

-- Если у типа ровно один конструктор, то для него можно определить эта-эквивалентность.

-- Например, для \Pi-типов она говорит, что (\lam x => f x) == f.
\func etaPi {A : \Type} (B : A -> \Type) (f : \Pi (x : A) -> B x) : f = (\lam x => f x) => idp

-- Для \Sigma-типов она говорит, что (p.1,p.2) == p.
\func etaSigma {A : \Type} (B : A -> \Type) (p : \Sigma (x : A) (B x)) : p = (p.1,p.2) => idp

-- Если бы эта-эквивалентности не было в языке, это равенство всё равно можно было бы доказать при помощи паттерн матчинга.
\func etaSigma' {A : \Type} (B : A -> \Type) (p : \Sigma (x : A) (B x)) : p = (p.1,p.2) \elim p
  | (a,b) => idp

-- Для типа пар определенного выше эта-эквивалентности нет, поэтому единственный способ доказать ее -- это использовать паттерн матчинг.
\func etaNatPair (p : NatPair) : p = natPair (natFst p) (natSnd p)
  | natPair x y => idp

-- 3. \record Pair, \new, \cowith, проекции, паттерн матчинг.

-- Records -- это \Sigma-типы с именованными полями.
\record NatPair'
  | fst : Nat
  | snd : Nat

-- Любое поле -- это просто функция, которая первым неявным параметром прнимает инстанс рекорда.
\func foo (p : NatPair') => fst {p}

-- Поля также лежат внутри модуля, соответствующего рекорду.
\func foo' (p : NatPair') => NatPair'.fst {p}

-- Можно использовать синтаксис через точку, но только если слева от точки стоит переменная и ее тип указан явно.
\func bar (p : NatPair') => p.snd

\func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\lam i => f (p @ i))

-- Следующий код не будет тайпчекаться, так как тип p не указан явно.
-- \func baz {p p' : NatPair'} (q : p = p') => pmap (\lam p => p.fst) q

-- Для создания элемента рекорда можно использовать ключевое слово \new.
\func zeroPair => \new NatPair' {
  | fst => 0
  | snd => 0
  }

-- Для рекордов есть эта-эквивалентность.
\func etaNatPair' (p : NatPair') : p = \new NatPair' { | fst => p.fst | snd => p.snd }
  => idp

\func foobar (p : NatPair') => fst {p} Nat.+ p.snd

\func foobar' (p : NatPair') : Nat
  | (a,b) => a Nat.+ b

-- Вместо \new можно использовать ключевое слово \cowith.
-- При этом мы говорим, что функция определяется при помощи копаттерн матчинга.
-- Для этого функция должна возвращать элемент некоторого рекорда.
-- После ключевого слова \cowith мы пишем список полей рекорда и значений, соответствующих этим полям.
\func zeroPair' : NatPair' \cowith
  | fst => 0
  | snd => 0

-- 4. Частичная реализация.

-- Можео использовать частичную реализацию классов.
-- Если C -- класс с полями f_1, ... f_n, то мы можем писать C { | f_{i_1} => e_{i_1} ... | f_{i_k} => e_{i_k} } для рекорда, где часть полей реализована указанным образом.
-- Например, NatPair' { | fst => 0 } -- это тип рекордов, где первое поле равно 0.
-- Такой тип эквивалентен просто типу второго поля, то есть натуральным числам.
-- Мы будем называть такие типы анонимными расширениями.
\func PartialEx : \Type => NatPair' { | fst => 0 }

-- На рекордах (и их анонимных расширениях) есть отношение подтипизации.
-- Если p имеет тип C { ... }, где реализованы какие-то поля, то он имеет и тип C { ... }, где реализовано подмножество этих полей.
-- Например:
\func partial (p : NatPair' { | fst => 0 | snd => 1 }) : PartialEx => p

\func PartialEx' => NatPair' { | fst => 3 | snd => 7 }

-- Оператор \new принимает произвольное выражение, которое должно вычисляться либо в рекорд, либо в его анонимное расширение.
-- Причем, должно быть верно, что все поля в этом рекорде/расширении реализованы.
\func new => \new PartialEx'

-- 5. Параметры, видимость полей.

-- Рекорды могут быть параметризованы.
\record Pair (A B : \Type)
  | fst_ : A
  | snd_ : B

-- Создавать элементы такого рекорда можно при помощи \new или \cowith как и раньше.
\func pairExample : Pair Nat (Nat -> Nat)
  => \new Pair { | fst_ => 1 | snd_ (x : Nat) => x }

-- На самом деле параметры рекорда являются его полями.
-- Пример выше эквивалентен следующему коду:
\func pairExample'
  => \new Pair { | A => Nat | B => Nat -> Nat | fst_ => 1 | snd_ (x : Nat) => x }

-- Мы можем все поля рекорда определить как параметры.
-- Например, следующий тип эквивалентен типу NatPari, определенному выше:
\record NatPair'' (fst'' snd'' : Nat)

-- Мы можем всё еще использовать \new и \cowith для него:
\func natPair''ex => \new NatPair'' {
  | fst'' => 0
  | snd'' => 0
  }

-- И наоборот, тип Pair эквивалентен следующему типу:
{-
\record Pair'
  | A : \Type
  | B : \Type
  | fst_ : A
  | snd_ : B
-}

-- Единственное отличие параметров и полей -- это то, что параметры по умолчанию не видны снаружи от класса, а поля видны.
-- Мы всё еще можем сделать параметры видимыми при помощи инструкции \open:
-- \open NatPair''
-- Либо мы можем обращаться к ним по полному имени:
\func natPair''foo => NatPair''.fst''

-- Верно и орабтное.
-- Если рекорд объявлен с полями, мы всё еще можем передавать их как аргументы при вызове:
\func natPairEx => \new NatPair' 0 0

-- То есть между полями и параметрами рекорда нет почти никакой разницы.

-- 6. Dependent records, тип положительных натуральных чисел.

\data Bool | true | false

\data T (b : Bool) \with
  | true => tt

\func isPos (n : Nat) : Bool
  | 0 => false
  | suc _ => true

-- Рекорды могут быть зависимыми, то есть типы полей могут зависеть от предыдущих полей.
-- Таким образом, рекорды полностью эквивалентны \Sigma-типам.

-- Например тип положительных натуральных чисел, который в теории множеств записывается как { n : Nat | T (isPos n) }, можно определить либо как \Sigma-тип \Sigma (n : Nat) (T (isPos n)), либо как рекорд:
\record PosNat (n : Nat) (p : T (isPos n))

-- 7. Monoid.

-- Еще один пример зависимых рекордов -- это тип моноидов.
-- Вместо ключевого слова \record мы использовали \class.
-- Классы почти полностью эквивалентны рекордам, но они предоставляют некоторую дополнительную функциональность.
\class Monoid (A : \Type)
  | id : A
  | \infixl 6 * : A -> A -> A
  | *-assoc (x y z : A) : (x * y) * z = x * (y * z)
  -- | *-assoc : \Pi (x y z : A) -> (x * y) * z = x * (y * z)
  | id-left (x : A) : id * x = x
  | id-right (x : A) : x * id = x

\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a)
  => coe (\lam i => B (p @ i)) b right

-- Транзитивность в инфиксной форме.
\func \infixr 5 *> {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a''
  => transport (\lam x => a = x) q p

-- При наследовании классов можно реализовывать некоторые поля, чтобы не приходилось их реализовывать в каждом инстансе.
\class CommMonoid \extends Monoid
  | *-comm (x y : A) : x * y = y * x
  | id-right x => *-comm x id *> id-left x

-- Мы можем использовать поля классов как и раньше:
\func baz (m : Monoid Nat 0 (Nat.+)) => m.*-assoc

-- 8. Классы, инстансы.

-- Отличие классов от рекодов заключается в том, что для классов реализован алгоритм вывода их инстансов наподобие того, как это сделано в хаскелле.
-- Мы можем определить инстанс класса следующим образом:
\instance NatMonoid : Monoid Nat
  | id => 1
  | * => Nat.*
  | *-assoc => {?}
  | id-left => {?}
  | id-right => {?}

-- Инстансы являются обычными функциями.
\func instEx => NatMonoid.id-left

\func instExF (M : Monoid) => M.id

\func instEx' => instExF NatMonoid

-- Поля класса имеют такой же тип как и поля рекорда:
-- * {M : Monoid} (x y : M.A) : M.A

-- Когда мы обращаемя к полю класса, первый неявный ищется среди доступных инстансов.
-- Доступными считаются только те инстансы, в которых классифицирующее поле равно подходящему типу.
-- Сейчас поле считается классифицирующим, если оно является первым явным параметром класса.
-- Например, в следующем примере первый неявный аргумент для * будет равен NatMonoid, так как это единственный инстанс моноида, в котором классифицирующее поле A равно Nat, типу аргументов этой функции.
\func f (x y : Nat) => x * y

-- Классы можно использовать как классы типов в хаскелле.
-- Например, класс Eq можно записать следующим образом:
\class Eq (A : \Type)
  | \infix 3 == (x y : A) : Bool

-- Функцию refl, которая в хасклее записывается следуюзим образом, можно описать двумя способами.
-- refl :: Eq a => a -> Bool
-- refl x = x == x
\func refl {A : \Type} {e : Eq A} (a : A) => a == a

\func refl' {E : Eq} (a : E) => a == a

-- 9. Coercing field.

-- Классицирующее поле обадает рядом дополнительных свойств.
-- Например, если в некотором месте ожидается элемент типа X, а передается элемент класса C, классифицирующее поле которого имеет тип X, оно будет неявно вставленно вместо этого значения.
-- Например, в следующем примере вместо M будет вставлено M.A, так как в этом месте ожидается элемент типа \Type, а передается элемент типа Monoid.
\func foobarbaz (M : Monoid) (x : M) => x

\data XXX | con

-- Кроме классифицирующих полей можно создавать собственные функции, преобразующии элемент одного типа в другой.
-- Для этого нужно в \where блоке к классу, рекорду или \data определить функцию при помощи ключевого слова \coerce вместо ключевого слова \func.
\data YYY | con' XXX Nat | con''
  \where {
    -- Можно преобразовывать либо к данному типу.
    -- При этом, функция должна возвращать элемент этого типа.
    \coerce fromXXX (x : XXX) => con' x 0
    
    -- Либо можно преобразовывать из данного типа.
    -- При этом функция должна принимать элемент данного типа в качестве последнего параметра.
    \coerce toXXX (y : YYY) => con
  }

\func fff (y : YYY) => y

-- Теперь элементы типа XXX неявно преобразуются к элементам типа YYY при помощи функции fromXXX.
\func ggg => fff con

-- Преобразование натуральных чисел к Int выполнено именно таким образом:
\func hhh : Int => 0

-- 10. \extends, diamond problem.

-- Рекорды и классы можно наследовать.
\record Base (A : \Type)

\record Base' (A : \Type)

\record X \extends Base
  | a : A

\record Y \extends Base'
  | b : A

-- При этом имена и типы полей ни на что не влияют.
-- В рекорде Z будет четыре поля: Base.A, Base'.A, a и b.
\record Z \extends X, Y

\func zzz => \new Z {
  | A => {?}
  | a => {?}
  | Base'.A => {?}
  | b => {?}
  }

-- Но в рекорде Z' будет только три поля, так как поле A из рекорда Base является одним и тем же и в рекорде X', и в рекода Y':

\record X' \extends Base
  | aa : A

\record Y' \extends Base
  | bb : A

\record Z' \extends X', Y'

-- Например, тип колец можно реализовать следующим образом.
\record AbGroup \extends CommMonoid {
  | inverse : A -> A
  | inv-left (x : A) : inverse x * x = id
  | inv-right (x : A) : x * inverse x = id
}

-- Чтобы отличать структуру сложения от структуры умножения, мы не наследуемся от моноида, но добавляем его как поля.
-- При этом, подлежащий тип и группы по сложению и моноида по умножению должен быть одинаковый.
-- Поэтому мы указываем в типе mulMonoid, что поле подлежащего типа реализовано определенным образом, а конкретно как подлежащий тип группы по сложению.
\record Ring \extends AbGroup
  | mulMonoid : Monoid A

-- Определим еще один тип абелевых групп, который не наследует моноиды.
\record AbGroup' (A : \Type) {
  -- Здесь нужно перечислить все поля из Monoid, CommMonoid и AbGroup.
}

-- Если мы попытаеся определить тип колец следующим образом, то у нас ничего не получится, так как структуры сложения и умножения будут совпадать.
\record Ring' \extends AbGroup', Monoid
  | Monoid.A => AbGroup'.A

-- 11. Functor.

-- Еще один пример: класс функторов.
\class Functor (F : \Type -> \Type)
  | fmap {A B : \Type} (f : A -> B) : F A -> F B
  | fmap-id {A : \Type} (y : F A) : fmap (\lam (x : A) => x) y = y
  | fmap-comp {A B C : \Type} (f : A -> B) (g : B -> C) (y : F A)
    : fmap (\lam x => g (f x)) y = fmap g (fmap f y)

-- 12. Синонимы классов.

-- Иногда у некоторого класса может существовать одновременно несколько инстансов.
-- В хаскелле данная проблема решается при помощи оборачивания типа в новый тип.
-- У нас есть другой вариант решения этой проблемы.
-- Мы можем определить синоним класса.
-- Для этого мы указываем его подлежащий класс и во что мы переименовываем его поля.
-- Например, мы можем определить синоним класса моноидов, который мы называем классом аддитивных моноидов.
-- В этом синоинме все поля переименованы в их аддитивные аналоги.
\class AddMonoid => Monoid {
  | id => zero
  | * => \infixl 6 +
  | *-assoc => +-assoc
  | id-left => zero-left
  | id-right => zero-right
}

-- Синонимы классов полностью взаимозаменяемы с их подлежащими классами.
-- Например, если у нас есть функция, которая ожидает аддитивный моноид, мы можем передать обычный, и наоборот.
\func addEx {A : AddMonoid} (x y : A) => x + y

\func addEx' => addEx {\new Monoid {
  | A => Nat
  | id => {?}
  | * => {?}
  | *-assoc => {?}
  | id-left => {?}
  | id-right => {?}
  }} 0 1

-- Основное предназначение синонимов классов заключается в том, что мы можем определять для них инстансы, которые отличаются от инстансов подлежащих классов.
-- Например, мы можем иметь инстанс моноида для натуральных чисел по умножению и инстанс аддитивного моноида для них же по сложению:
\instance NatAddMonoid : AddMonoid Nat
  | zero => 0
  | + => Nat.+
  | +-assoc => {?}
  | zero-left => {?}
  | zero-right => {?}

-- Оба инстанса можно использовать одновременно:
\func example => 0 + 1 * 2
